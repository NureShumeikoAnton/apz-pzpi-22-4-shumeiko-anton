Харківський університет радіоелектроніки
Факультет комп'ютерних наук
Кафедра програмної інженерії




ЗВІТ
до практичної роботи №1 з дисципліни
"Архітектура програмного забезпечення"
на тему: "Патерни проєктування"




Виконав ст. гр. ПЗПІ-22-4
Шумейко Антон Олександрович

Перевірив
ст. викладач кафедри ПІ
Сокорчук Ігор Петрович








Харків 2025
1 ІСТОРІЯ ЗМІН

	Таблиця 1 – Історія змін
№	Дата	Версія звіту	Опис змін та виправлень
1	23.03.2025	0.1	Створено початкову структуру звіту та заповнено основні розділи.
2	25.03.2025	0.2	Додано деталізований опис структури патерну Memento та принципів його роботи.
3	27.03.2025	0.3	Розширено розділи про практичне застосування та додано програмний код з коментарями.
4	29.03.2025	0.4	Оновлено висновки та додано посилання відеозапис. Додано презентацію у додатки.

2 ЗАВДАННЯ

1. Підготувати доповідь на тему: «Шаблон (патерн) проєктування ПЗ» (із книг: Ґамма, “ООП. Патерни проєктування”, GoF, крім патерна Singletone)
2. Створити та оформити слайди презентації доповіді
3. Створити та опублікувати на YouTube відеозапис доповіді
4. Оформити та завантажити на dl.nure.ua звіт до виконаної роботи
5. При потребі створити та налаштувати у GitHub обліковий запис для облікового запису студента в домені @nure.ua
6. Створити для виконання завдань з дисципліни GitHub репозиторій iз вказаним на https://dl.nure.ua іменем та з головною гілкою main
7. Створити у корені створеного репозиторію файл README.md з вказаним далі змістом та вказані далі директорії для окремих завдань
8. Експортувати звіт у файл у простому текстововому форматі та завантажити цей файл у директорію Pract1 у репозиторії GitHub
9. Завантажити у вказану далі піддиректорію увесь програмний код, який розглядається у доповіді ПЗ1

3 ОПИС ВИКОНАНОЇ РОБОТИ
	
3.1. Дослідження патерну Знімок

В рамках виконаної роботи було проведено всебічне дослідження патерну проектування Знімок. Цей патерн відноситься до поведінкових патернів проектування та дозволяє зберігати та відновлювати попередній стан об'єкта без порушення інкапсуляції.

3.2 Структура патерну Знімок

Під час дослідження було визначено основні компоненти патерну Знімок:
 Originator (Творець): клас, стан якого необхідно зберігати та відновлювати. Створює об'єкт Знімок, що містить знімок поточного внутрішнього стану.
 Memento (Знімок): клас, що зберігає внутрішній стан об'єкта Originator. Захищає цей стан від доступу інших об'єктів, окрім Originator.
 Caretaker (Опікун): клас, відповідальний за збереження об'єкта Знімок, але не має доступу до його вмісту.

3.3 Принципи роботи патерну

Було досліджено основні принципи роботи патерну Знімок:

1. Творець створює знімок свого поточного стану, коли це необхідно.
2. Опікун зберігає знімок (або кілька знімків) для подальшого використання.
3. Коли потрібно відновити стан, Опікун повертає необхідний знімок Творцю.
4. Творець відновлює свій внутрішній стан на основі даних із знімка.

3.4 Розробка прикладу реалізації патерну

Під час виконання практичного завдання було розроблено приклад реалізації патерну Знімок у вигляді програмного коду. Детальний програмний код наведено у додатку В.
Для наочної демонстрації роботи патерну Знімок було розроблено презентацію, яка містить основні теоретичні аспекти та приклади використання. Презентація представлена у додатку Б.
Також було створено відеозапис доповіді, посилання на який розміщено у додатку А.

4 ВИСНОВКИ

	В рамках виконаної роботи було досліджено патерн проектування Знімок, його структуру, принципи роботи та можливості застосування в реальних проектах. Завдяки використанню патерну Знімок вдалося вирішити проблему збереження та відновлення попередніх станів об'єкта без порушення принципу інкапсуляції.
Основними перевагами патерну є збереження інкапсуляції внутрішнього стану об'єкта, спрощення структури основного класу та забезпечення надійного механізму відновлення станів. Досліджений патерн є особливо корисним при розробці функціональності "скасувати/повторити", збереженні історії змін об'єктів та реалізації контрольних точок у програмних додатках.
Результатом виконання практичного завдання є програмний код, що демонструє застосування патерну Знімок (див. додаток В), презентація, у якій викладено основні положення про застосування розглянутого шаблону (див. додаток Б), а також відеозапис, що розміщено у додатку А.
ДОДАТОК А
Посилання на відеозапис доповіді

Відеозапис доповіді на YouTube: https://youtu.be/ClRwN1CnuyY
00:00 Привітання
00:11 Вступ. Загальна інформація про патерни проєктування
00:49 Опис шаблону "Знімок". Основна ідея патерну та основні компоненти
01:40 Структура патерну "Знімок". Графічне відображення принципу роботи патерну
02:10 Передумови для застосування. Приклади ситуацій, коли розробнику може знадобитись використання патерну "Знімок"
02:44 Переваги та недоліки використання. Перелік особливостей при використанні патерну, як позитивних, так і негативних
03:32 Різновиди реалізації. Наведено декілька можливих різновидів реалізації патерну "Знімок"
04:27 Приклад проблеми, яку вирішить патерн "Знімок" при розробці функціоналу "скасувати" для текстового редактору
05:13 Перший крок впровадження. Створення додатково класу "Знімок" вкладеним у клас Творця
05:46 Другий крок впровадження. Додавання методів для збереження та відновлення стану
06:20 Третій крок впровадження. Додавання клас "Опікун" для керування історією
06:51 Приклад використання. Приклад застосування створених класів у реальному програмному застосунку
07:34 Порівняння з іншими патернами. Порівняння патерну "Знімок" з іншими патернами проєктування з метою знаходження спільного та відмінного
08:34 Висновки. Підбиття підсумків доповіді та повторення принципу застосування патерну "Знімок"
09:10 Список використаних джерел
ДОДАТОК Б
Презентація «Шаблон (патерн) проєктування “Знімок”»
 
Рисунок Б.1 – Титульний слайд презентації

 
Рисунок Б.2 – Вступна частина та інформація про патерни проєктування



 
Рисунок Б.3 – Опис шаблону «Знімок» та основні компоненти

 
Рисунок Б.4 – Структура патерну «Знімок»

 
Рисунок Б.5 – Передумови застосування

 
Рисунок Б.6 – Переваги та недоліки використання

 
Рисунок Б.7 – Різновиди реалізації

 
Рисунок Б.8 – Приклад застосування: проблема

 
Рисунок Б.9 – Приклад застосування: Клас «Знімок»

 
Рисунок Б.10 – Приклад застосування: Додавання методу для відновлення стану

 
Рисунок Б.11 – Приклад застосування: Створення Caretaker для управління історією

 
Рисунок Б.12 – Приклад застосування: Використання

 
Рисунок Б.13 – Порівняння із схожими патернами

 
Рисунок Б.14 – Висновки

 
Рисунок Б.15 – Список використаних джерел
 
ДОДАТОК В
Приклад програмного коду

Клас редактора без застосування патернів проєктування:
1  import java.util.ArrayList;

2  public class TextEditor_Basic {
3  private String text = "";

4  public void write(String text) {
5  this.text += text;
6  }

7  public String getText() {
8  return text;
9  }

10  // Проблема: як реалізувати скасування змін?
11  // Погане рішення: зберігати історію як масив рядків
12  private ArrayList<String> history = new ArrayList<>();

13  public void save() {
14  history.add(text);
15  }

16  public void undo() {
17  if (history.size() > 0) {
18  text = history.remove(history.size() - 1);
19  }
20  }
21  }

Клас редактора із вкладеним класом Знімку:
1  public class TextEditor {
2  private String text = "";
3  private String fontName = "Arial";
4  private int fontSize = 12;

5  public String getText() {
6  return text;
7  }

8  public void write(String text) {
9  this.text += text;
10  }

11  public void setFont(String fontName, int fontSize) {
12  this.fontName = fontName;
13  this.fontSize = fontSize;
14  }

15  // Створення знімка
16  public EditorState save() {
17  return new EditorState(text, fontName, fontSize);
18  }

19  // Відновлення зі знімка
20  public void restore(EditorState memento) {
21  this.text = memento.getText();
22  this.fontName = memento.getFontName();
23  this.fontSize = memento.getFontSize();
24  }

25  // Вкладений клас Memento
26  public static class EditorState {
27  private final String text;
28  private final String fontName;
29  private final int fontSize;

30  private EditorState(String text, String fontName, int fontSize) {
31  this.text = text;
32  this.fontName = fontName;
33  this.fontSize = fontSize;
34  }

35  private String getText() {
36  return text;
37  }

38  private String getFontName() {
39  return fontName;
40  }

41  private int getFontSize() {
42  return fontSize;
43  }
44  }
45  }

Клас Опікун для зберігання історії змін:
1  import java.util.Stack;

2  public class TextEditorHistory {
3  private final Stack<TextEditor.EditorState> history = new Stack<>();

4  public void save(TextEditor editor) {
5  history.push(editor.save());
6  }

7  public void undo(TextEditor editor) {
8  if (!history.isEmpty()) {
9  editor.restore(history.pop());
10  }
11  }
12  }


Використання класів у застосунку:
1  public class Main {
2  public static void main(String[] args) {
3  TextEditor editor = new TextEditor();
4  TextEditorHistory history = new TextEditorHistory();

5  // Перше редагування
6  editor.write("Це перший абзац. ");
7  editor.setFont("Times New Roman", 14);
8  history.save(editor);

9  // Друге редагування
10  editor.write("Це другий абзац. ");
11  history.save(editor);

12  // Третє редагування
13  editor.write("Це третій абзац. ");
14  editor.setFont("Calibri", 16);

15  // Відміна останніх змін
16  System.out.println("Поточний текст: " + editor.getText());
17  history.undo(editor);
18  System.out.println("Після першого скасування: " + editor.getText());
19  history.undo(editor);
20  System.out.println("Після другого скасування: " + editor.getText());
21  }
22  }